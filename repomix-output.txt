This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-31T15:16:16.697Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Directory Structure
================================================================
run/
  create.ts
  frame.ts
  scope.ts
  task.ts
  types.ts
  value.ts
abort-signal.ts
all.ts
async.ts
call.ts
channel.ts
context.ts
deps.ts
each.ts
ensure.ts
events.ts
instructions.ts
lazy.ts
lift.ts
main.ts
mod.ts
pause.ts
queue.ts
race.ts
result.ts
run.ts
shift-sync.ts
signal.ts
sleep.ts
types.ts

================================================================
Files
================================================================

================
File: run/create.ts
================
export function create<T>(
  tag: string,
  attrs: Partial<T>,
  prototype: Partial<T>,
): T {
  let properties: Record<string, PropertyDescriptor> = {};
  for (let [key, value] of Object.entries(attrs)) {
    properties[key] = { enumerable: true, value };
  }
  return Object.create({
    ...prototype,
    [Symbol.toStringTag]: tag,
  }, properties);
}

================
File: run/frame.ts
================
import type { Frame, Instruction, Operation, Result } from "../types.ts";

import { evaluate, shift } from "../deps.ts";
import { shiftSync } from "../shift-sync.ts";
import { lazy } from "../lazy.ts";
import { Err, Ok } from "../result.ts";

import type { Exit, FrameResult } from "./types.ts";
import { createValue } from "./value.ts";
import { createTask } from "./task.ts";
import { create } from "./create.ts";

let ids = 0;

export interface FrameOptions<T> {
  operation(): Operation<T>;
  parent?: Frame["context"];
}

export function createFrame<T>(options: FrameOptions<T>): Frame<T> {
  return evaluate<Frame<T>>(function* () {
    let { operation, parent } = options;
    let children = new Set<Frame>();
    let context = Object.create(parent ?? {});
    let thunks: IteratorResult<Thunk, Result<T>>[] = [{
      done: false,
      value: $next(void 0),
    }];

    let crash: Error | undefined = void 0;

    let interrupt = () => {};

    let [setResults, results] = yield* createValue<FrameResult<T>>();

    let frame = yield* shiftSync<Frame<T>>((k) => {
      let self: Frame<T> = create<Frame<T>>("Frame", { id: ids++, context }, {
        createChild<X>(operation: () => Operation<X>) {
          let child = createFrame<X>({ operation, parent: self.context });
          children.add(child);
          evaluate(function* () {
            yield* child;
            children.delete(child);
          });
          return child;
        },
        getTask() {
          let task = createTask(self);
          self.getTask = () => task;
          return task;
        },
        enter() {
          k.tail(self);
        },
        crash(error: Error) {
          abort(error);
          return results;
        },
        destroy() {
          abort();
          return results;
        },
        [Symbol.iterator]: results[Symbol.iterator],
      });

      let abort = (reason?: Error) => {
        if (!self.aborted) {
          self.aborted = true;
          crash = reason;
          thunks.unshift({ done: false, value: $abort() });
          interrupt();
        }
      };

      return self;
    });

    let iterator = lazy(() => operation()[Symbol.iterator]());

    let thunk = thunks.pop()!;

    while (!thunk.done) {
      let getNext = thunk.value;
      try {
        let next: IteratorResult<Instruction> = getNext(iterator());

        if (next.done) {
          thunks.unshift({ done: true, value: Ok(next.value) });
        } else {
          let instruction = next.value;

          let outcome = yield* shift<InstructionResult>(function* (k) {
            interrupt = () => k.tail({ type: "interrupted" });

            try {
              k.tail({
                type: "settled",
                result: yield* instruction(frame),
              });
            } catch (error) {
              k.tail({ type: "settled", result: Err(error) });
            }
          });

          if (outcome.type === "settled") {
            if (outcome.result.ok) {
              thunks.unshift({
                done: false,
                value: $next(outcome.result.value),
              });
            } else {
              thunks.unshift({
                done: false,
                value: $throw(outcome.result.error),
              });
            }
          }
        }
      } catch (error) {
        thunks.unshift({ done: true, value: Err(error) });
      }
      thunk = thunks.pop()!;
    }

    frame.exited = true;

    let result = thunk.value;

    let exit: Exit<T>;

    if (!result.ok) {
      exit = { type: "result", result };
    } else if (crash) {
      exit = { type: "crashed", error: crash };
    } else if (frame.aborted) {
      exit = { type: "aborted" };
    } else {
      exit = { type: "result", result };
    }

    let destruction = Ok(void 0);

    while (children.size !== 0) {
      for (let child of [...children].reverse()) {
        let teardown = yield* child.destroy();
        if (!teardown.ok) {
          destruction = teardown;
        }
      }
    }

    if (!destruction.ok) {
      setResults({ ok: false, error: destruction.error, exit, destruction });
    } else {
      if (exit.type === "aborted") {
        setResults({ ok: true, value: void 0, exit, destruction });
      } else if (exit.type === "result") {
        let { result } = exit;
        if (result.ok) {
          setResults({ ok: true, value: void 0, exit, destruction });
        } else {
          setResults({ ok: false, error: result.error, exit, destruction });
        }
      } else {
        setResults({ ok: false, error: exit.error, exit, destruction });
      }
    }
  });
}

type Thunk = ReturnType<typeof $next>;

// deno-lint-ignore no-explicit-any
const $next = <T>(value: any) =>
  function $next(i: Iterator<Instruction, T>) {
    return i.next(value);
  };

const $throw = <T>(error: Error) =>
  function $throw(i: Iterator<Instruction, T>) {
    if (i.throw) {
      return i.throw(error);
    } else {
      throw error;
    }
  };

const $abort = <T>(value?: unknown) =>
  function $abort(i: Iterator<Instruction, T>) {
    if (i.return) {
      return i.return(value as unknown as T);
    } else {
      return { done: true, value } as IteratorResult<Instruction, T>;
    }
  };

type InstructionResult =
  | {
    type: "settled";
    result: Result<unknown>;
  }
  | {
    type: "interrupted";
  };

================
File: run/scope.ts
================
import type { Context, Frame, Future, Operation, Scope } from "../types.ts";
import { evaluate } from "../deps.ts";
import { create } from "./create.ts";
import { createFrame } from "./frame.ts";
import { getframe, suspend } from "../instructions.ts";

/**
 * Get the scope of the currently running {@link Operation}.
 *
 * @returns an operation yielding the current scope
 */
export function* useScope(): Operation<Scope> {
  let frame = yield* getframe();
  let [scope] = createScope(frame);
  return scope;
}

/**
 * Create a new scope to serve as an entry point from normal
 * JavaScript execution into Effection.
 *
 * When creating a fresh scope (as opposed to capturing a reference to
 * an existing one via {@link useScope}) it is the responsibility of
 * the creator of the new scope to destroy it when it is no longer needed.
 *
 * @example
 * ```javascript
 * let [scope, destroy] = createScope();
 * let task = scope.run(function*() {
 *   //do some long running work
 * });
 *
 * //... later
 * await destroy();
 *
 * ```
 * @returns a tuple containing the new scope, and a function to destroy it.
 */
export function createScope(frame?: Frame): [Scope, () => Future<void>] {
  let parent = frame ?? createFrame({ operation: suspend });

  let scope = create<Scope>("Scope", {}, {
    run<T>(operation: () => Operation<T>) {
      if (parent.exited) {
        let error = new Error(
          `cannot call run() on a scope that has already been exited`,
        );
        error.name = "InactiveScopeError";
        throw error;
      }

      let frame = parent.createChild(operation);
      frame.enter();

      evaluate(function* () {
        let result = yield* frame;
        if (!result.ok) {
          yield* parent.crash(result.error);
        }
      });

      return frame.getTask();
    },
    get<T>(context: Context<T>) {
      let { key, defaultValue } = context;
      return (parent.context[key] ?? defaultValue) as T | undefined;
    },
    set<T>(context: Context<T>, value: T) {
      let { key } = context;
      parent.context[key] = value;
      return value;
    },
  });

  parent.enter();

  return [scope, parent.getTask().halt];
}

================
File: run/task.ts
================
import type { Frame, Future, Reject, Resolve, Result, Task } from "../types.ts";

import { evaluate } from "../deps.ts";
import { Err } from "../result.ts";
import { action } from "../instructions.ts";

import type { FrameResult } from "./types.ts";
import { create } from "./create.ts";

export function createTask<T>(
  frame: Frame<T>,
): Task<T> {
  let promise: Promise<T>;

  let awaitResult = (resolve: Resolve<T>, reject: Reject) => {
    evaluate(function* () {
      let result = getResult(yield* frame);

      if (result.ok) {
        resolve(result.value);
      } else {
        reject(result.error);
      }
    });
  };

  let getPromise = () => {
    promise = new Promise<T>((resolve, reject) => {
      awaitResult(resolve, reject);
    });
    getPromise = () => promise;
    return promise;
  };

  let task = create<Task<T>>("Task", {}, {
    *[Symbol.iterator]() {
      let frameResult = evaluate<FrameResult<T> | void>(() => frame);
      if (frameResult) {
        let result = getResult(frameResult);
        if (result.ok) {
          return result.value;
        } else {
          throw result.error;
        }
      } else {
        return yield* action<T>(function* (resolve, reject) {
          awaitResult(resolve, reject);
        });
      }
    },
    then: (...args) => getPromise().then(...args),
    catch: (...args) => getPromise().catch(...args),
    finally: (...args) => getPromise().finally(...args),
    halt() {
      let haltPromise: Promise<void>;
      let getHaltPromise = () => {
        haltPromise = new Promise((resolve, reject) => {
          awaitHaltResult(resolve, reject);
        });
        getHaltPromise = () => haltPromise;
        frame.destroy();
        return haltPromise;
      };
      let awaitHaltResult = (resolve: Resolve<void>, reject: Reject) => {
        evaluate(function* () {
          let { destruction } = yield* frame;
          if (destruction.ok) {
            resolve();
          } else {
            reject(destruction.error);
          }
        });
      };
      return create<Future<void>>("Future", {}, {
        *[Symbol.iterator]() {
          let result = evaluate<FrameResult<T> | void>(() => frame);

          if (result) {
            if (!result.ok) {
              throw result.error;
            }
          } else {
            yield* action<void>(function* (resolve, reject) {
              awaitHaltResult(resolve, reject);
              frame.destroy();
            });
          }
        },
        then: (...args) => getHaltPromise().then(...args),
        catch: (...args) => getHaltPromise().catch(...args),
        finally: (...args) => getHaltPromise().finally(...args),
      });
    },
  });
  return task;
}

function getResult<T>(result: FrameResult<T>): Result<T> {
  if (!result.ok) {
    return result;
  } else if (result.exit.type === "aborted") {
    return Err(Error("halted"));
  } else if (result.exit.type === "crashed") {
    return Err(result.exit.error);
  } else {
    return result.exit.result;
  }
}

================
File: run/types.ts
================
import type { Result } from "../types.ts";

export type Exit<T> = {
  type: "aborted";
} | {
  type: "crashed";
  error: Error;
} | {
  type: "result";
  result: Result<T>;
};

/**
 * @ignore
 */
export type FrameResult<T> = Result<void> & {
  exit: Exit<T>;
  destruction: Result<void>;
};

================
File: run/value.ts
================
import { type Computation, reset } from "../deps.ts";
import { type Resolve } from "../types.ts";
import { shiftSync } from "../shift-sync.ts";

export function* createValue<T>(): Computation<[Resolve<T>, Computation<T>]> {
  let result: { value: T } | void = void 0;
  let listeners = new Set<Resolve<T>>();

  let resolve = yield* reset<Resolve<T>>(function* () {
    let value = yield* shiftSync<T>((k) => k.tail);

    result = { value };

    for (let listener of listeners) {
      listeners.delete(listener);
      listener(value);
    }
  });

  let event: Computation<T> = {
    [Symbol.iterator]() {
      if (result) {
        return sync(result.value);
      } else {
        return shiftSync<T>((k) => {
          listeners.add(k.tail);
        })[Symbol.iterator]();
      }
    },
  };
  return [resolve, event];
}

export interface Queue<T> {
  add(item: T): void;
  next(): Computation<T>;
}

export function sync<T>(value: T) {
  return {
    next() {
      return { done: true, value } as const;
    },
  };
}

================
File: abort-signal.ts
================
import type { Operation } from "./types.ts";
import { resource } from "./instructions.ts";

/**
 * Create an
 * [`AbortSignal`](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal)
 * bound to the current scope. Whenever that scope is completed,
 * errored, or halted, the abort signal will be triggered.
 *
 * Cancellation and teardown is handled automatically in Effection,
 * but in systems where it is not, the lifespan of a transaction needs
 * to be explicitly modeled. A very common way to do this is with the
 * `AbortSignal`. By creating an abort signal bound to an Effection
 * scope, we can pass that signal down to 3rd party consumers that can
 * use it to register shutdown callbacks that will be invoked whenever
 * the task is done (either by completion, failure, or
 * cancellation). An example is the native
 * [`fetch()`](https://developer.mozilla.org/en-US/docs/Web/API/Fetch#syntax)
 * API which takes a `signal` parameter in order to trigger when the
 * HTTP request should be cancelled.  This is how you would bind the
 * lifetime of the HTTP request to the lifetime of the current task.
 *
 * @example
 * ```javascript
 * function* request() {
 *   let signal = yield* useAbortSignal();
 *   return yield* fetch('/some/url', { signal });
 * }
 * ```
 */
export function useAbortSignal(): Operation<AbortSignal> {
  return resource(function* AbortSignal(provide) {
    let controller = new AbortController();
    try {
      yield* provide(controller.signal);
    } finally {
      controller.abort();
    }
  });
}

================
File: all.ts
================
import type { Operation, Task, Yielded } from "./types.ts";
import { spawn } from "./instructions.ts";
import { call } from "./call.ts";

/**
 * Block and wait for all of the given operations to complete. Returns
 * an array of values that the given operations evaluated to. This has
 * the same purpose as
 * [Promise.all](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all).
 *
 * If any of the operations become errored, then `all` will also become errored.
 *
 * ### Example
 *
 * ``` javascript
 * import { all, expect, main } from 'effection';
 *
 * await main(function*() {
 *  let [google, bing] = yield* all([
 *    expect(fetch('http://google.com')),
 *    expect(fetch('http://bing.com')),
 *   ]);
 *  // ...
 * });
 * ```
 *
 * @param ops a list of operations to wait for
 * @returns the list of values that the operations evaluate to, in the order they were given
 */
export function all<T extends readonly Operation<unknown>[] | []>(
  ops: T,
): Operation<All<T>> {
  return call(function* () {
    let tasks: Task<unknown>[] = [];
    for (let operation of ops) {
      tasks.push(yield* spawn(() => operation));
    }
    let results = [];
    for (let task of tasks) {
      results.push(yield* task);
    }
    return results as All<T>;
  });
}

/**
 * This type allows you to infer heterogenous operation types.
 * e.g. `all([sleep(0), expect(fetch("https://google.com")])`
 * will have a type of `Operation<[void, Request]>`
 */

type All<T extends readonly Operation<unknown>[] | []> = {
  -readonly [P in keyof T]: Yielded<T[P]>;
};

================
File: async.ts
================
import type { Stream, Subscription } from "./types.ts";

import { call } from "./call.ts";

/**
 * Convert any [`AsyncIterator`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncIterator) into an effection {@link Subscription}
 *
 * This allows you to consume any `AsyncIterator` as a {@link Subscription}.
 *
 * @param iter - the iterator to convert
 * @returns a subscription that will produce each item of `iter`
 */
export function subscribe<T, R>(iter: AsyncIterator<T, R>): Subscription<T, R> {
  return {
    next: () => call(() => iter.next()),
  };
}

/**
 * Convert any [`AsyncIterable`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_async_iterator_and_async_iterable_protocols) into an Effection {@link Stream}.
 *
 * This allows you to consume any `AsyncIterable` as a {@link Stream}.
 *
 * @param iterable - the async iterable to convert
 * @returns a stream that will produce each item of `iterable`
 */
export function stream<T, R>(iterable: AsyncIterable<T, R>): Stream<T, R> {
  return {
    *[Symbol.iterator]() {
      return subscribe(iterable[Symbol.asyncIterator]());
    },
  };
}

interface AsyncIterable<T, TReturn = unknown> {
  [Symbol.asyncIterator](): AsyncIterator<T, TReturn>;
}

================
File: call.ts
================
import type { Instruction, Operation } from "./types.ts";
import { action } from "./instructions.ts";
import { pause } from "./pause.ts";

/**
 * A uniform integration type representing anything that can be evaluated
 * as a the parameter to {@link call}.
 *
 * {@link call} converts a `Callable` into an `Operation` which can then be used
 * anywhere within Effection.
 *
 * APIs that accept `Callable` values allow end developers to pass simple
 * functions without necessarily needing to know anything about Operations.
 *
 * ```javascript
 * function hello(to: Callable<string>): Operation<string> {
 *   return function*() {
 *     return `hello ${yield* call(to)}`;
 *   }
 * }
 *
 * await run(() => hello(() => "world!")); // => "hello world!"
 * await run(() => hello(async () => "world!")); // => "hello world!"
 * await run(() => hello(function*() { return "world!" })); "hello world!";
 * ```
 */
export type Callable<T> =
  | Operation<T>
  | Promise<T>
  | (() => Operation<T>)
  | (() => Promise<T>)
  | (() => T);

/**
 * Pause the current operation, then runs a promise, async function, plain function,
 * or operation within a new scope. The calling operation will be resumed (or errored)
 * once call is completed.
 *
 * `call()` is a uniform integration point for calling async functions,
 * evaluating promises, generator functions, operations, and plain
 * functions.
 *
 * It can be used to treat a promise as an operation:
 *
 * @example
 * ```javascript
 * let response = yield* call(fetch('https://google.com'));
 * ```
 *
 * or an async function:
 *
 * @example
 * ```typescript
 * async function* googleSlowly() {
 *   return yield* call(async function() {
 *     await new Promise(resolve => setTimeout(resolve, 2000));
 *     return await fetch("https://google.com");
 *   });
 * }
 * ```
 *
 * It can be used to run an operation in a separate scope to ensure that any
 * resources allocated will be cleaned up:
 *
 * @example
 * ```javascript
 * yield* call(function*() {
 *   let socket = yield* useSocket();
 *   return yield* socket.read();
 * }); // => socket is destroyed before returning
 * ```
 *
 * It can be used to run a plain function:
 *
 * @example
 * ```javascript
 * yield* call(() => "a string");
 * ```
 *
 * Because `call()` runs within its own {@link Scope}, it can also be used to
 * establish {@link  * establish error boundaries https://frontside.com/effection/docs/errors | error boundaries}.
 *
 * @example
 * ```javascript
 * function* myop() {
 *   let task = yield* spawn(function*() {
 *     throw new Error("boom!");
 *   });
 *   yield* task;
 * }
 *
 * function* runner() {
 *   try {
 *     yield* myop();
 *   } catch (err) {
 *     // this will never get hit!
 *   }
 * }
 *
 * function* runner() {
 *   try {
 *     yield* call(myop);
 *   } catch(err) {
 *     // properly catches `spawn` errors!
 *   }
 * }
 * ```
 *
 * @param callable the operation, promise, async function, generator funnction, or plain function to call as part of this operation
 */
export function call<T>(callable: () => Operation<T>): Operation<T>;
export function call<T>(callable: () => Promise<T>): Operation<T>;
export function call<T>(callable: () => T): Operation<T>;
export function call<T>(callable: Operation<T>): Operation<T>;
export function call<T>(callable: Promise<T>): Operation<T>;
export function call<T>(callable: Callable<T>): Operation<T> {
  return action(function* (resolve, reject) {
    try {
      if (typeof callable === "function") {
        let fn = callable as () => Operation<T> | Promise<T> | T;
        resolve(yield* toop(fn()));
      } else {
        resolve(yield* toop(callable));
      }
    } catch (error) {
      reject(error);
    }
  });
}

function toop<T>(
  op: Operation<T> | Promise<T> | T,
): Operation<T> {
  if (isPromise(op)) {
    return expect(op);
  } else if (isIterable(op)) {
    let iter = op[Symbol.iterator]();
    if (isInstructionIterator<T>(iter)) {
      // operation
      return op;
    } else {
      // We are assuming that if an iterator does *not* have `.throw` then
      // it must be a built-in iterator and we should return the value as-is.
      return bare(op as T);
    }
  } else {
    return bare(op as T);
  }
}

function bare<T>(val: T): Operation<T> {
  return {
    [Symbol.iterator]() {
      return { next: () => ({ done: true, value: val }) };
    },
  };
}

function expect<T>(promise: Promise<T>): Operation<T> {
  return pause((resolve, reject) => {
    promise.then(resolve, reject);
    return () => {};
  });
}

function isFunc(f: unknown): f is (...args: unknown[]) => unknown {
  return typeof f === "function";
}

function isPromise<T>(p: unknown): p is Promise<T> {
  if (!p) return false;
  return isFunc((p as Promise<T>).then);
}

// iterator must implement both `.next` and `.throw`
// built-in iterators are not considered iterators to `call()`
function isInstructionIterator<T>(it: unknown): it is Iterator<Instruction, T> {
  if (!it) return false;
  return isFunc((it as Iterator<Instruction, T>).next) &&
    isFunc((it as Iterator<Instruction, T>).throw);
}

function isIterable<T>(it: unknown): it is Iterable<T> {
  if (!it) return false;
  return typeof (it as Iterable<T>)[Symbol.iterator] === "function";
}

================
File: channel.ts
================
import type { Operation, Stream } from "./types.ts";
import { createSignal } from "./signal.ts";
import { lift } from "./lift.ts";

/**
 * A broadcast channel that multiple consumers can subscribe to the
 * via the same {@link Stream}, and messages sent to the channel are
 * received by all consumers. The channel is not buffered, so if there
 * are no consumers, the message is dropped.
 */
export interface Channel<T, TClose> extends Stream<T, TClose> {
  /**
   * Send a message to all subscribers of this {@link Channel}
   */
  send(message: T): Operation<void>;

  /**
   * End every subscription to this {@link Channel}
   */
  close(value: TClose): Operation<void>;
}

/**
 * Create a new {@link Channel}. Use channels to communicate between operations.
 * In order to dispatch messages from outside an operation such as from a
 * callback, use {@link Signal}.
 *
 * See [the guide on Streams and
 * Subscriptions](https://frontside.com/effection/docs/guides/collections)
 * for more details.
 *
 * @example
 *
 * ``` javascript
 * import { main, createChannel } from 'effection';
 *
 * await main(function*() {
 *   let channel = createChannel();
 *
 *   yield* channel.send('too early'); // the channel has no subscribers yet!
 *
 *   let subscription1 = yield* channel;
 *   let subscription2 = yield* channel;
 *
 *   yield* channel.send('hello');
 *   yield* channel.send('world');
 *
 *   console.log(yield* subscription1.next()); //=> { done: false, value: 'hello' }
 *   console.log(yield* subscription1.next()); //=> { done: false, value: 'world' }
 *   console.log(yield* subscription2.next()); //=> { done: false, value: 'hello' }
 *   console.log(yield* subscription2.next()); //=> { done: false, value: 'world' }
 * });
 * ```
 */
export function createChannel<T, TClose = void>(): Channel<T, TClose> {
  let signal = createSignal<T, TClose>();

  return {
    send: lift(signal.send),
    close: lift(signal.close),
    [Symbol.iterator]: signal[Symbol.iterator],
  };
}

================
File: context.ts
================
import type { Context } from "./types.ts";
import { create } from "./run/create.ts";
import { useScope } from "./run/scope.ts";

export function createContext<T>(key: string, defaultValue?: T): Context<T> {
  let context: Context<T> = create<Context<T>>(`Context`, { key }, {
    defaultValue,
    *get() {
      let scope = yield* useScope();
      return scope.get(context);
    },
    *set(value: T) {
      let scope = yield* useScope();
      return scope.set(context, value);
    },
    *[Symbol.iterator]() {
      let value = yield* context.get();
      if (typeof value === "undefined") {
        throw new MissingContextError(`missing required context: '${key}'`);
      } else {
        return value;
      }
    },
  });

  return context;
}

class MissingContextError extends Error {
  name = "MissingContextError";
}

================
File: deps.ts
================
export { assert } from "https://deno.land/std@0.158.0/testing/asserts.ts";
export * from "https://deno.land/x/continuation@0.1.5/mod.ts";

================
File: each.ts
================
import type { Operation, Stream, Subscription } from "./types.ts";
import { createContext } from "./context.ts";

/**
 * Consume an effection stream using a simple for-of loop.
 *
 * Given any stream, you can access its values sequentially using the `each()`
 * operation just as you would use `for await of` loop with an async iterable:
 *
 * ```javascript
 * function* logvalues(stream) {
 *   for (let value of yield* each(stream)) {
 *     console.log(value);
 *     yield* each.next()
 *   }
 * }
 * ```
 * You must always invoke `each.next` at the end of each iteration of the loop,
 * including if the interation ends with a `continue` statement.
 *
 * Note that just as with async iterators, there is no way to consume the
 * `TClose` value of a stream using the `for-each` loop.
 *
 * @typeParam T - the type of each value in the stream.
 * @param stream - the stream to iterate
 * @returns an operation to iterate `stream`
 */
export function each<T>(stream: Stream<T, unknown>): Operation<Iterable<T>> {
  return {
    *[Symbol.iterator]() {
      let subscription = yield* stream;
      let current = yield* subscription.next();
      let stack = yield* EachStack.get();
      if (!stack) {
        stack = yield* EachStack.set([]);
      }

      let context: EachLoop<T> = { subscription, current };

      stack.push(context);

      let iterator: Iterator<T> = {
        next() {
          if (context.stale) {
            let error = new Error(
              `for each loop did not use each.next() operation before continuing`,
            );
            error.name = "IterationError";
            throw error;
          } else {
            context.stale = true;
            return context.current;
          }
        },
        return() {
          stack!.pop();
          return { done: true, value: void 0 };
        },
      };

      return {
        [Symbol.iterator]: () => iterator,
      };
    },
  };
}

each.next = function next() {
  return {
    name: "each.next()",
    *[Symbol.iterator]() {
      let stack = yield* EachStack;
      let context = stack[stack.length - 1];
      if (!context) {
        let error = new Error(`cannot call next() outside of an iteration`);
        error.name = "IterationError";
        throw error;
      }
      let current = yield* context.subscription.next();
      delete context.stale;
      context.current = current;
      if (current.done) {
        stack.pop();
      }
    },
  } as Operation<void>;
};

interface EachLoop<T> {
  subscription: Subscription<T, unknown>;
  current: IteratorResult<T>;
  stale?: true;
}

const EachStack = createContext<EachLoop<unknown>[]>("each");

================
File: ensure.ts
================
import { Operation } from "./types.ts";
import { resource } from "./instructions.ts";

/**
 * Run the given function or operation when the current operation
 * shuts down. This is equivalent to running the function or operation
 * in a `finally {}` block, but it can help you avoid rightward drift.
 *
 * @example
 *
 * ```javascript
 * import { main, ensure } from 'effection';
 * import { createServer } from 'http';
 *
 * await main(function*() {
 *   let server = createServer(...);
 *   yield* ensure(() => { server.close() });
 * });
 * ```
 *
 * Note that you should wrap the function body in braces, so the function
 * returns `undefined`.
 *
 * @example
 *
 * ```javascript
 * import { main, ensure, once } from 'effection';
 * import { createServer } from 'http';
 *
 * await main(function*() {
 *   let server = createServer(...);
 *   yield* ensure(function* () {
 *     server.close();
 *     yield* once(server, 'closed');
 *   });
 * });
 * ```
 *
 * Your ensure function should return an operation whenever you need to do
 * asynchronous cleanup. Otherwise, you can return `void`
 *
 * @param fn - a function which returns an {@link Operation} or void
 */
export function ensure(fn: () => Operation<unknown> | void): Operation<void> {
  return resource(function* (provide) {
    try {
      yield* provide();
    } finally {
      let result = fn();
      if (result && typeof result[Symbol.iterator] === "function") {
        yield* result;
      }
    }
  });
}

================
File: events.ts
================
// deno-lint-ignore-file no-explicit-any ban-types
import { createSignal } from "./signal.ts";
import { resource } from "./instructions.ts";
import type { Operation, Stream, Subscription } from "./types.ts";

type FN = (...any: any[]) => any;

type EventTypeFromEventTarget<T, K extends string> = `on${K}` extends keyof T
  ? Parameters<Extract<T[`on${K}`], FN>>[0]
  : Event;

/**
 * @ignore
 */
export type EventList<T> = T extends {
  addEventListener(type: infer P, ...args: any): void;
  // we basically ignore this but we need it so we always get the first override of addEventListener
  addEventListener(type: infer P2, ...args: any): void;
} ? P & string
  : never;

/**
 * Create an {@link Operation} that yields the next event to be emitted by an
 * [EventTarget](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget).
 *
 * @param target - the event target to be watched
 * @param name - the name of the event to watch. E.g. "click"
 * @returns an Operation that yields the next emitted event
 */
export function once<
  T extends EventTarget,
  K extends EventList<T> | (string & {}),
>(target: T, name: K): Operation<EventTypeFromEventTarget<T, K>> {
  return {
    *[Symbol.iterator]() {
      let subscription = yield* on(target, name);
      let next = yield* subscription.next();
      return next.value;
    },
  };
}

/**
 * Create a {@link Stream} of events from any
 * [EventTarget](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget).
 *
 * See the guide on [Streams and Subscriptions](https://frontside.com/effection/docs/collections)
 * for details on how to use streams.
 *
 * @param target - the event target whose events will be streamed
 * @param name - the name of the event to stream. E.g. "click"
 * @returns a stream that will see one item for each event
 */
export function on<
  T extends EventTarget,
  K extends EventList<T> | (string & {}),
>(target: T, name: K): Stream<EventTypeFromEventTarget<T, K>, never> {
  return resource(function* (provide) {
    let signal = createSignal<Event>();

    target.addEventListener(name, signal.send);

    try {
      yield* provide(
        yield* signal as Operation<
          Subscription<EventTypeFromEventTarget<T, K>, never>
        >,
      );
    } finally {
      target.removeEventListener(name, signal.send);
    }
  });
}

================
File: instructions.ts
================
import type {
  Frame,
  Instruction,
  Operation,
  Provide,
  Reject,
  Resolve,
  Result,
  Task,
} from "./types.ts";

import { reset, shift } from "./deps.ts";
import { shiftSync } from "./shift-sync.ts";
import { Err, Ok } from "./result.ts";

/**
 * Indefinitely pause execution of the current operation. It is typically
 * used in conjunction with an {@link action} to mark the boundary
 * between setup and teardown.
 *
 * ```js
 * function onEvent(listener, name) {
 *   return action(function* (resolve) {
 *     try {
 *       listener.addEventListener(name, resolve);
 *       yield* suspend();
 *     } finally {
 *       listener.removeEventListener(name, resolve);
 *     }
 *   });
 * }
 * ```
 *
 * An operation will remain suspended until its enclosing scope is destroyed,
 * at which point it proceeds as though return had been called from the point
 * of suspension. Once an operation suspends once, further suspend operations
 * are ignored.
 *
 * @returns an operation that suspends the current operation
 */
export function suspend(): Operation<void> {
  return instruction(Suspend);
}

function Suspend(frame: Frame) {
  return shiftSync<Result<void>>((k) => {
    if (frame.aborted) {
      k.tail(Ok(void 0));
    }
  });
}

/**
 * Create an {@link Operation} that can be either resolved (or rejected) with
 * a synchronous callback. This is the Effection equivalent of `new Promise()`.
 *
 * The action body is itself an operation that runs in a new scope that is
 * destroyed completely before program execution returns to the point where the
 * action was yielded to.
 *
 * For example:
 *
 * ```js
 * let five = yield* action(function*(resolve, reject) {
 *   setTimeout(() => {
 *     if (Math.random() > 5) {
 *       resolve(5)
 *     } else {
 *       reject(new Error("bad luck!"));
 *     }
 *   }, 1000);
 * });
 *
 * ```
 *
 * However, it is customary to explicitly {@link suspend} inside the body of the
 * action so that whenever the action resolves, appropriate cleanup code can
 * run. The preceeding example would be more correctly written as:
 *
 * ```js
 * let five = yield* action(function*(resolve) {
 *   let timeoutId = setTimeout(() => {
 *     if (Math.random() > 5) {
 *       resolve(5)
 *     } else {
 *       reject(new Error("bad luck!"));
 *     }
 *   }, 1000);
 *   try {
 *     yield* suspend();
 *   } finally {
 *     clearTimout(timeoutId);
 *   }
 * });
 * ```
 *
 * @typeParam T - type of the action's result.
 * @param operation - body of the action
 * @returns an operation producing the resolved value, or throwing the rejected error
 */
export function action<T>(
  operation: (resolve: Resolve<T>, reject: Reject) => Operation<void>,
): Operation<T> {
  return instruction(function Action(frame) {
    return shift<Result<T>>(function* (k) {
      let settle = yield* reset<Resolve<Result<T>>>(function* () {
        let result = yield* shiftSync<Result<T>>((k) => k.tail);

        let destruction = yield* child.destroy();

        if (!destruction.ok) {
          k.tail(destruction);
        } else {
          k.tail(result);
        }
      });

      let resolve: Resolve<T> = (value) => settle(Ok(value));
      let reject: Reject = (error) => settle(Err(error));

      let child = frame.createChild(function* () {
        yield* operation(resolve, reject);
        yield* suspend();
      });

      yield* reset(function* () {
        let result = yield* child;
        if (!result.ok) {
          k.tail(result);
        }
      });

      child.enter();
    });
  });
}

/**
 * Run another operation concurrently as a child of the current one.
 *
 * The spawned operation will begin executing immediately and control will
 * return to the caller when it reaches its first suspend point.
 *
 * ### Example
 *
 * ```typescript
 * import { main, sleep, suspend, spawn } from 'effection';
 *
 * await main(function*() {
 *   yield* spawn(function*() {
 *     yield* sleep(1000);
 *     console.log("hello");
 *   });
 *   yield* spawn(function*() {
 *     yield* sleep(2000);
 *     console.log("world");
 *   });
 *   yield* suspend();
 * });
 * ```
 *
 * You should prefer using the spawn operation over calling
 * {@link Scope.run} from within Effection code. The reason being that a
 * synchronous failure in the spawned operation will not be caught
 * until the next yield point when using `run`, which results in lines
 * being executed that should not.
 *
 * ### Example
 *
 * ```typescript
 * import { main, suspend, spawn, useScope } from 'effection';
 *
 * await main(function*() {
 *   yield* useScope();
 *
 *   scope.run(function*() {
 *    throw new Error('boom!');
 *   });
 *
 *   console.log('this code will run and probably should not');
 *
 *   yield* suspend(); // <- error is thrown after this.
 * });
 * ```
 * @param operation the operation to run as a child of the current task
 * @typeParam T the type that the spawned task evaluates to
 * @returns a {@link Task} representing a handle to the running operation
 */
export function spawn<T>(operation: () => Operation<T>): Operation<Task<T>> {
  return instruction(function Spawn(frame) {
    return shift<Result<Task<T>>>(function (k) {
      let child = frame.createChild<T>(operation);

      child.enter();

      k.tail(Ok(child.getTask()));

      return reset(function* () {
        let result = yield* child;
        if (!result.ok) {
          yield* frame.crash(result.error);
        }
      });
    });
  });
}

/**
 * Define an Effection [resource](https://frontside.com/effection/docs/resources)
 *
 * Resources are a type of operation that passes a value back to its caller
 * while still allowing that operation to run in the background. It does this
 * by invoking the special `provide()` operation. The caller pauses until the
 * resource operation invokes `provide()` at which point the caller resumes with
 * passed value.
 *
 * `provide()` suspends the resource operation until the caller passes out of
 * scope.
 *
 * @example
 * ```javascript
 * function useWebSocket(url) {
 *   return resource(function*(provide) {
 *     let socket = new WebSocket(url);
 *     yield* once(socket, 'open');
 *
 *     try {
 *       yield* provide(socket);
 *     } finally {
 *       socket.close();
 *       yield* once(socket, 'close');
 *     }
 *   })
 * }
 *
 * await main(function*() {
 *   let socket = yield* useWebSocket("wss://example.com");
 *   socket.send("hello world");
 * });
 * ```
 *
 * @param operation the operation defining the lifecycle of the resource
 * @returns an operation yielding the resource
 */
export function resource<T>(
  operation: (provide: Provide<T>) => Operation<void>,
): Operation<T> {
  return instruction((frame) =>
    shift<Result<T>>(function (k) {
      function provide(value: T) {
        k.tail(Ok(value));
        return suspend();
      }

      let child = frame.createChild(() => operation(provide));

      child.enter();

      return reset(function* () {
        let result = yield* child;
        if (!result.ok) {
          k.tail(result);
          yield* frame.crash(result.error);
        }
      });
    })
  );
}

/**
 * @ignore
 */
export function getframe(): Operation<Frame> {
  return instruction((frame) =>
    shiftSync<Result<Frame>>((k) => k.tail(Ok(frame)))
  );
}

// An optimized iterator that yields the instruction on the first call
// to next, then returns its value on the second. Equivalent to:
// {
//  *[Symbol.iterator]() { return yield instruction; }
// }
function instruction<T>(i: Instruction): Operation<T> {
  return {
    [Symbol.iterator]() {
      let entered = false;
      return {
        next(value) {
          if (!entered) {
            entered = true;
            return { done: false, value: i };
          } else {
            return { done: true, value };
          }
        },
        throw(error) {
          throw error;
        },
      };
    },
  };
}

================
File: lazy.ts
================
export function lazy<T>(create: () => T): () => T {
  let thunk = () => {
    let value = create();
    thunk = () => value;
    return value;
  };
  return () => thunk();
}

================
File: lift.ts
================
import { shift } from "./deps.ts";
import { type Operation } from "./types.ts";

/**
 * Convert a simple function into an {@link Operation}
 *
 * @example
 * ```javascript
 * let log = lift((message) => console.log(message));
 *
 * export function* run() {
 *   yield* log("hello world");
 *   yield* log("done");
 * }
 * ```
 *
 * @returns a function returning an operation that invokes `fn` when evaluated
 */
export function lift<TArgs extends unknown[], TReturn>(
  fn: (...args: TArgs) => TReturn,
): (...args: TArgs) => Operation<TReturn> {
  return (...args: TArgs) => {
    return ({
      *[Symbol.iterator]() {
        return yield () => {
          return shift(function* (k) {
            k.tail({ ok: true, value: fn(...args) });
          });
        };
      },
    });
  };
}

================
File: main.ts
================
import { createContext } from "./context.ts";
import { type Operation } from "./types.ts";
import { action } from "./instructions.ts";
import { run } from "./run.ts";

/**
 * Halt process execution immediately and initiate shutdown. If a message is
 * provided, it will be logged to the console after shutdown:
 *
 * ```js
 * if (invalidArgs()) {
 *   yield* exit(5, "invalid arguments")
 * }
 * ```
 * @param status - the exit code to use for the process exit
 * @param message - message to print to the console before exiting.
 * @param returns an operation that exits the program
 */
export function* exit(status: number, message?: string): Operation<void> {
  let escape = yield* ExitContext;
  escape({ status, message });
}

/**
 * Top-level entry point to programs written in Effection. That means that your
 * program should only call `main` once, and everything the program does is
 * handled from within `main` including an orderly shutdown. Unlike `run`, `main`
 * automatically prints errors that occurred to the console.
 *
 * Use the {@link exit} operation form within to halt program execution
 * immediately and initiate shutdown.
 *
 * The behavior of `main` is slightly different depending on the environment it
 * is running in.
 *
 * ### Deno, Node
 *
 * When running within Deno or Node, any error which reaches `main` causes the
 * entire process to exit with an exit code of `1`.
 *
 * Additionally, handlers for `SIGINT` are attached to the
 * process, so that sending an exit signal to it causes the main task
 * to become halted. This means that hitting CTRL-C on an Effection program
 * using `main` will cause an orderly shutdown and run all cleanup code.
 *
 * > Warning! do not call `Deno.exit()` on Deno or `process.exit()` on Node
 * > directly, as this will not gracefully shutdown. Instead, use the
 * > {@link exit} operation.
 *
 * ### Browser
 *
 * When running in a browser, The `main` operation gets shut down on the
 * `unload` event.
 *
 * @param body - an operation to run as the body of the program
 * @returns a promise that resolves right after the program exits
 */

export async function main(
  body: (args: string[]) => Operation<void>,
): Promise<void> {
  let hardexit = (_status: number) => {};

  let result = await run(() =>
    action<Exit>(function* (resolve) {
      // action will return shutdown immediately upon resolve, so stash
      // this function in the exit context so it can be called anywhere.
      yield* ExitContext.set(resolve);

      // this will hold the event loop and prevent runtimes such as
      // Node and Deno from exiting prematurely.
      let interval = setInterval(() => {}, Math.pow(2, 30));

      try {
        let interrupt = {
          SIGINT: () => resolve({ status: 130, signal: "SIGINT" }),
          SIGTERM: () => resolve({ status: 143, signal: "SIGTERM" }),
        };

        yield* withHost({
          *deno() {
            hardexit = (status) => Deno.exit(status);
            try {
              Deno.addSignalListener("SIGINT", interrupt.SIGINT);
              Deno.addSignalListener("SIGTERM", interrupt.SIGTERM);
              yield* body(Deno.args.slice());
            } finally {
              Deno.removeSignalListener("SIGINT", interrupt.SIGINT);
              Deno.removeSignalListener("SIGTERM", interrupt.SIGTERM);
            }
          },
          *node() {
            //@ts-expect-error type-checked by Deno, run on Node
            hardexit = (status) => global.process.exit(status);
            try {
              //@ts-expect-error type-checked by Deno, run on Node
              process.on("SIGINT", interrupt.SIGINT);
              //@ts-expect-error type-checked by Deno, run on Node
              process.on("SIGTERM", interrupt.SIGTERM);
              //@ts-expect-error type-checked by Deno, run on Node
              yield* body(global.process.argv.slice(2));
            } finally {
              //@ts-expect-error this runs on Node
              process.off("SIGINT", interrupt.SIGINT);
              //@ts-expect-error this runs on Node
              process.off("SIGTERM", interrupt.SIGINT);
            }
          },
          *browser() {
            try {
              self.addEventListener("unload", interrupt.SIGINT);
              yield* body([]);
            } finally {
              self.removeEventListener("unload", interrupt.SIGINT);
            }
          },
        });

        yield* exit(0);
      } catch (error) {
        resolve({ status: 1, error });
      } finally {
        clearInterval(interval);
      }
    })
  );

  if (result.message) {
    if (result.status === 0) {
      console.log(result.message);
    } else {
      console.error(result.message);
    }
  }

  if (result.error) {
    console.error(result.error);
  }

  hardexit(result.status);
}

const ExitContext = createContext<(exit: Exit) => void>("exit");

interface Exit {
  status: number;
  message?: string;
  signal?: string;
  error?: Error;
}

interface HostOperation<T> {
  deno(): Operation<T>;
  node(): Operation<T>;
  browser(): Operation<T>;
}

function* withHost<T>(op: HostOperation<T>): Operation<T> {
  let global = globalThis as Record<string, unknown>;

  if (typeof global.Deno !== "undefined") {
    return yield* op.deno();
    // this snippet is from the node-detect npm package
  } else if (
    Object.prototype.toString.call(
      //@ts-expect-error dev env is deno, but this is safe to run.
      typeof process !== "undefined" ? process : 0,
    ) === "[object process]"
  ) {
    return yield* op.node();
  } else {
    return yield* op.browser();
  }
}

================
File: mod.ts
================
export * from "./types.ts";
export * from "./channel.ts";
export * from "./context.ts";
export * from "./instructions.ts";
export * from "./call.ts";
export * from "./run.ts";
export * from "./sleep.ts";
export * from "./async.ts";
export * from "./abort-signal.ts";
export * from "./result.ts";
export * from "./lift.ts";
export * from "./events.ts";
export * from "./main.ts";
export * from "./all.ts";
export * from "./each.ts";
export * from "./queue.ts";
export * from "./signal.ts";
export * from "./ensure.ts";
export * from "./race.ts";

================
File: pause.ts
================
import type { Operation, Reject, Resolve, Result } from "./types.ts";
import { Err, Ok } from "./result.ts";
import { shift } from "./deps.ts";

export function* pause<T>(
  install: (resolve: Resolve<T>, reject: Reject) => Resolve<void>,
): Operation<T> {
  let uninstall = () => {};
  try {
    return yield function pause_i() {
      return shift<Result<T>>(function* (k) {
        let resolve = (value: T) => k.tail(Ok(value));
        let reject = (error: Error) => k.tail(Err(error));
        uninstall = install(resolve, reject);
      });
    };
  } finally {
    if (uninstall) {
      uninstall();
    }
  }
}

================
File: queue.ts
================
import type { Resolve, Subscription } from "./types.ts";
import { pause } from "./pause.ts";

/**
 * A FIFO queue which can be used to implement the {@link Subscription}
 * interface directly. Most of the time, you will use either a {@link Signal}
 * or a {@link Channel} as the mechanism, but `Queue` allows you to manage
 * a single subscription directly.
 *
 * @typeParam T the type of the items in the queue
 * @typeParam TClose the type of the value that the queue is closed with
 */
export interface Queue<T, TClose> extends Subscription<T, TClose> {
  /**
   * Add a value to the queue. The oldest value currently in the queue will
   * be the first to be read.
   * @param item - the value to add
   */
  add(item: T): void;

  /**
   * Close the queue.
   * @param value - the queue's final value.
   */
  close(value: TClose): void;
}

/**
 * Creates a new queue. Queues are unlimited in size and sending a message to a
 * queue is always synchronous.
 *
 * @example
 *
 * ```javascript
 * import { each, main, createQueue } from 'effection';
 *
 * await main(function*() {
 *   let queue = createQueue<number>();
 *   queue.send(1);
 *   queue.send(2);
 *   queue.send(3);
 *
 *   let next = yield* queue.subscription.next();
 *   while (!next.done) {
 *     console.log("got number", next.value);
 *     next = yield* queue.subscription.next();
 *   }
 * });
 * ```
 *
 * @typeParam T the type of the items in the queue
 * @typeParam TClose the type of the value that the queue is closed with
 */
export function createQueue<T, TClose>(): Queue<T, TClose> {
  type Item = IteratorResult<T, TClose>;

  let items: Item[] = [];
  let consumers = new Set<Resolve<Item>>();

  function enqueue(item: Item) {
    items.unshift(item);
    while (items.length > 0 && consumers.size > 0) {
      let [consume] = consumers;
      let top = items.pop() as Item;
      consume(top);
    }
  }

  return {
    add: (value) => enqueue({ done: false, value }),
    close: (value) => enqueue({ done: true, value }),
    *next() {
      let item = items.pop();
      if (item) {
        return item;
      } else {
        return yield* pause<Item>((resolve) => {
          consumers.add(resolve);
          return () => consumers.delete(resolve);
        });
      }
    },
  };
}

================
File: race.ts
================
import type { Operation, Yielded } from "./types.ts";
import { action, spawn } from "./instructions.ts";

/**
 * Race the given operations against each other and return the value of
 * whichever operation returns first. This has the same purpose as
 * [Promise.race](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race).
 *
 * If an operation become errored first, then `race` will fail with this error.
 * After the first operation wins the race, all other operations will become
 * halted and therefore cannot throw any further errors.
 *
 * @example
 *
 * ```typescript
 * import { main, race, fetch } from 'effection';
 *
 * await main(function*() {
 *  let fastest = yield* race([fetch('http://google.com'), fetch('http://bing.com')]);
 *  // ...
 * });
 * ```
 *
 * @param operations a list of operations to race against each other
 * @returns the value of the fastest operation
 */
export function race<T extends Operation<unknown>>(
  operations: readonly T[],
): Operation<Yielded<T>> {
  return action<Yielded<T>>(function* (resolve, reject) {
    for (let operation of operations) {
      yield* spawn(function* () {
        try {
          resolve((yield* operation) as Yielded<T>);
        } catch (error) {
          reject(error);
        }
      });
    }
  });
}

================
File: result.ts
================
import type { Result } from "./types.ts";

/**
 * @ignore
 */
export const Ok = <T>(value: T): Result<T> => ({ ok: true, value });

/**
 * @ignore
 */
export const Err = <T>(error: Error): Result<T> => ({ ok: false, error });

================
File: run.ts
================
import type { Operation, Task } from "./types.ts";
import { createFrame } from "./run/frame.ts";
export * from "./run/scope.ts";

/**
 * Execute an operation.
 *
 * Run is an entry point into Effection, and is especially useful when
 * embedding Effection code into existing code. However, If you are writing your
 * whole program using Effection, you should prefer {@link main}.
 *
 * @example
 * ```javascript
 * import { run, useAbortSignal } from 'effection';
 *
 * async function fetchExample() {
 *   await run(function*() {
 *     let signal = yield* useAbortSignal();
 *     let response = yield* fetch('http://www.example.com', { signal });
 *     yield* response.text();
 *   });
 * });
 * ```
 *
 * Run will create a new top-level scope for the operation. However, to run an
 * operation in an existing scope, you can use {@link Scope.run}.
 *
 * @param operation the operation to run
 * @returns a task representing the running operation.
 */
export function run<T>(operation: () => Operation<T>): Task<T> {
  let frame = createFrame<T>({ operation });
  frame.enter();
  return frame.getTask();
}

================
File: shift-sync.ts
================
import { type Computation, type Continuation, shift } from "./deps.ts";

/**
 * Create a shift computation where the body of the shift can be resolved
 * in a single step.
 *
 * before:
 * ```ts
 * yield* shift(function*(k) { return k; });
 * ```
 * after:
 * yield* shiftSync(k => k);
 */
export function shiftSync<T>(
  block: (resolve: Continuation<T>, reject: Continuation<Error>) => void,
): Computation<T> {
  return shift<T>((resolve, reject) => {
    return {
      [Symbol.iterator]: () => ({
        next() {
          let value = block(resolve, reject);
          return { done: true, value };
        },
      }),
    };
  });
}

================
File: signal.ts
================
import type { Stream, Subscription } from "./types.ts";

import { createQueue, type Queue } from "./queue.ts";
import { resource } from "./instructions.ts";
import { createContext } from "./context.ts";

/**
 * Convert plain JavaScript function calls into a {@link Stream} that can
 * be consumed within an operation. If no operation is subscribed to a signal's
 * stream, then sending messages to it is a no-op.
 *
 * Signals are particularly suited to be installed as event listeners.
 *
 * @example
 * ```typescript
 * import { createSignal, each } from "effection";
 *
 * export function* logClicks(function*(button) {
 *   let clicks = createSignal<MouseEvent>();
 *
 *   button.addEventListener("click", clicks.send);
 *
 *   try {
 *     for (let click of yield* each(clicks)) {
 *       console.log(`click:`, click);
 *       yield* each.next();
 *     }
 *   } finally {
 *     button.removeEventListener("click", clicks.send);
 *   }
 * })
 * ````
 *
 * @typeParam T - type of each event sent by this signal
 * @typeParam TClose - type of the final event sent by this signal
 */
export interface Signal<T, TClose> extends Stream<T, TClose> {
  /**
   * Send a value to all the consumers of this signal.
   *
   * @param value - the value to send.
   */
  send(value: T): void;

  /**
   * Send the final value of this signal to all its consumers.
   * @param value - the final value.
   */
  close(value: TClose): void;
}

/**
 * @ignore
 * {@link Context} that contains a {@link Queue} factory to be used when creating a {@link Signal}.
 *
 * This allows end-users to customize a Signal's Queue.
 *
 * @example
 * ```javascript
 * export function useActions(pattern: ActionPattern): Stream<AnyAction, void> {
 *  return {
 *    *[Symbol.iterator]() {
 *      const actions = yield* ActionContext;
 *      yield* QueueFactory.set(() => createFilterQueue(matcher(pattern));
 *      return yield* actions;
 *    }
 *  }
 * }
 *
 * function createFilterQueue(predicate: Predicate) {
 *  let queue = createQueue();
 *
 *  return {
 *    ...queue,
 *    add(value) {
 *      if (predicate(value)) {
 *        queue.add(value);
 *      }
 *    }
 *  }
 * }
 * ```
 */
export const SignalQueueFactory = createContext(
  "Signal.createQueue",
  createQueue,
);

/**
 * Create a new {@link Signal}
 *
 * Signal should be used when you need to send messages to a stream
 * from _outside_ of an operation. The most common case of this is to
 * connect a plain, synchronous JavaScript callback to an operation.
 *
 * @example
 * ```javascript
 * function* logClicks(button) {
 *   let clicks = createSignal<MouseEvent>();
 *   try {
 *     button.addEventListener("click", clicks.send);
 *
 *     for (let click of yield* each(clicks)) {
 *       console.log("click", click);
 *     }
 *    } finally {
 *      button.removeEventListener("click", clicks.send);
 *    }
 * }
 * ```
 *
 * Do not use a signal to send messages from within an operation as it could
 * result in out-of-scope code being executed. In those cases, you should use a
 * {@link Channel}.
 */
export function createSignal<T, TClose = never>(): Signal<T, TClose> {
  let subscribers = new Set<Queue<T, TClose>>();

  let subscribe = resource<Subscription<T, TClose>>(function* (provide) {
    let newQueue = yield* SignalQueueFactory;
    let queue = newQueue<T, TClose>();
    subscribers.add(queue);

    try {
      yield* provide({ next: queue.next });
    } finally {
      subscribers.delete(queue);
    }
  });

  function send(value: T) {
    for (let queue of [...subscribers]) {
      queue.add(value);
    }
  }

  function close(value: TClose) {
    for (let queue of [...subscribers]) {
      queue.close(value);
    }
  }

  return { ...subscribe, send, close };
}

================
File: sleep.ts
================
import type { Operation } from "./types.ts";
import { action, suspend } from "./instructions.ts";

/**
 * Sleep for the given amount of milliseconds.
 *
 * @example
 * ```typescript
 * import { main, sleep } from 'effection';
 *
 * await main(function*() {
 *   yield* sleep(2000);
 *   console.log("Hello lazy world!");
 * });
 * ```
 *
 * @param duration - the number of milliseconds to sleep
 */
export function sleep(duration: number): Operation<void> {
  return action(function* sleep(resolve) {
    let timeoutId = setTimeout(resolve, duration);
    try {
      yield* suspend();
    } finally {
      clearTimeout(timeoutId);
    }
  });
}

================
File: types.ts
================
// deno-lint-ignore-file no-explicit-any
import type { Computation } from "./deps.ts";

/**
 * An `Operation` in Effection describes an abstract computation. An operation
 * does not do anything on its own. Rather, it only describes the steps it will
 * take when it runs.
 *
 * In the Effection world, `Operation` occupies the same position as `Promise`
 * does the world of async/await.
 *
 * An operation can be created with a generator function that only does `yield*`
 * to other operations:
 *
 * @example
 * ```javascript
 * import { sleep } from "effection";

 * function* slow5(seconds) {
 *   yield* sleep(seconds * 1000);
 *   return 5;
 * }
 * ```
 *
 * Operations can also be created using `Symbol.iterator`. The following
 * operation is the same as above:
 *
 * @example
 * ```javascript
 * import { sleep } from "effection";
 *
 * const slow5 = (seconds) => ({
 *   *[Symbol.iterator]() {
 *     yield* sleep(seconds * 1000);
 *     return 5;
 *   }
 * })
 * ```
 *
 * See [Operations guide](https://frontside.com/effection/v3/docs/operations) for more information.
 *
 */
export interface Operation<T> {
  [Symbol.iterator](): Iterator<Instruction, T, any>;
}

/**
 * A value that is both an {@link Operation} _and_ `Promise`.
 *
 * Futures are operations that are implicitly associated with an Effection scope
 * and so they can be freely `await`ed within any async functions. However, they
 * can also be evaluated directly within another operation, so among other
 * things, if the operation resolves synchronously, it will continue within the
 * same tick of the run loop.
 */
export interface Future<T> extends Promise<T>, Operation<T> {}

/**
 * A handle to a concurrently running operation that lets you either use the
 * result of that operation, or shut it down.
 *
 * When it is run or spawned, an operation executes concurrently with
 * the rest of the program. The `Task` is both an {@link Operation} and a
 * `Promise` that lets you consume the result of that operation.
 *
 * @example
 * ```javascript
 * import { run, sleep } from "effection";
 *
 * let task = run(function*() {
 *   yield* sleep(100);
 *   return "hello world"
 * });
 *
 * console.log(await task); //=> "hello world"
 * ```
 *
 * A task can also be created from within an operation by using the
 * {@link spawn()} operation.
 *
 * @example
 * ```javascript
 * import { run, spawn, sleep } from "effection";
 *
 * await run(function*() {
 *   let task = yield* spawn(function*() {
 *     yield* sleep(100);
 *     return "hello world";
 *   });
 *   console.log(yield* task;) //=> "hello world"
 * });
 * ```
 *
 * Note tasks are subject to the strict guarantees of structured concurrency
 * and will never outlive their parent. For example, the following spawned task
 * will never log any output to the console.
 *
 * @example
 * ```javascript
 * import { run, spawn, sleep } from "effection";
 *
 * await run(function*() {
 *   yield* spawn(function*() {
 *     yield* sleep(100);
 *     console.log("hello world");
 *   });
 *   // <--- returns here, so spawned task is shut down as it sleeps.
 * });
 * ```
 *
 * See the guide on [Scopes](https://frontside.com/effection/docs/scope) for
 * more detail.
 *
 * If a `Task` is halted before it finishes executing, then consuming it's
 * result is an Error.
 *
 * @example
 * ```javascript
 * import { run, spawn, sleep } from "effection";
 *
 * await run(function*() {
 *  let task = yield* spawn(function*() {
 *    yield* sleep(100);
 *    return "hello world";
 *  });
 *  yield* task.halt();
 *  let output = yield* task; //=> throws Error("halted");
 *  console.log(output);
 * });
 * ```
 *
 * @see {@link run}
 * @see {@link spawn}
 * @see {@link Scope.run}
 */
export interface Task<T> extends Future<T> {
  /**
   * Interrupt and shut down a running {@link Operation} and all of its
   * children.
   *
   * Any errors raised by the `halt()` operation only represent problems that
   * occured during the teardown of the task. In other words, `halt()` can
   * succeed even if the task failed.
   *
   * @returns a future that only resolves when all shutdown associated with this
   * Task is complete.
   */
  halt(): Future<void>;
}

export type Resolve<T = unknown> = (value: T) => void;

export type Reject = (error: Error) => void;

export type Provide<T> = (value: T) => Operation<void>;

/**
 * A programatic API to interact with an Effection scope from outside of an
 * {@link Operation}.
 *
 * Most often this is used to integrate external APIs with Effection by
 * capturing a `Scope` from a running operation with {@link useScope}, and then
 * using it to call back into itself from a callback.
 *
 * The following example calls into Effection to implement a proxy around a
 * google search by using [express.js](https://expressjs.com).
 *
 * @example
 * ```javascript
 * import { main, useScope, suspend } from "effection";
 * import { express } from "express";
 *
 * await main(function*() {
 *   let scope = yield* useScope();
 *   express().get("/", (req, resp) => {
 *     return scope.run(function*() {
 *       let signal = yield* useAbortSignal();
 *       let response = yield* fetch(`https://google.com?q=${req.params.q}`, { signal });
 *       resp.send(yield* response.text());
 *     });
 *   });
 *   yield* suspend();
 * });
 * ```
 */
export interface Scope {
  /**
   * Spawn an {@link Operation} within `Scope`.
   *
   * This is used to create concurrent tasks from _outside_ of a running
   * operation.
   *
   * @param operation - the operation to run
   * @returns a task rep
   */
  run<T>(operation: () => Operation<T>): Task<T>;
  /**
   * Get a {@link Context} value from outside of an operation.
   * @param context - the context to get
   * @returns the value of that context in this scope if it exists
   */
  get<T>(context: Context<T>): T | undefined;

  /**
   * Set the value of a {@link Context} from outside of an operation
   * @param context - the context to set
   * @param value - the value to set for this context
   * @returns - the value that was set
   */
  set<T>(context: Context<T>, value: T): T;
}

/**
 * The Effection equivalent of an [`AsyncIterable`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_async_iterator_and_async_iterable_protocols).
 *
 * Like async iterables, streams do not actually have state themselves, but
 * contain the recipe for how to create a {@link Subscription}
 *
 * @see https://frontside.com/effection/docs/collections#stream
 */
export type Stream<T, TReturn> = Operation<Subscription<T, TReturn>>;

/**
 * The Effection equivalent of an [`AsyncIterator`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncIterator)
 *
 * A subscription acts like a stateful queue that provides a sequence of values
 * via the next() method. Normally a subscription is created via a
 * {@link Stream}.
 *
 * @see https://effection.deno.dev/docs/collections#subscription
 */
export interface Subscription<T, R> {
  next(): Operation<IteratorResult<T, R>>;
}

/**
 * `Context`` defines a value which is in effect for a given scope which is an
 * (action, resource, call, or spawn).
 *
 * When used as an operation, it gets the value of the Context from
 * the current scope. If it has not been set, and there is no default
 * value, then a `MissingContextError` will be raised.
 *
 * Unless a context value is defined for a particular scope, it will inherit
 * its value from its parent scope.
 */
export interface Context<T> extends Operation<T> {
  /**
   * A unique identifier for this context.
   */
  readonly key: string;

  /**
   * The value of the context if has not been defined for the current operation.
   */
  readonly defaultValue?: T;

  /**
   * Set the value of the Context for the current scope.
   */
  set(value: T): Operation<T>;

  /**
   * Get the value of the Context from the current scope. If it has not been
   * set, and there is no default value, then this will return `undefined`.
   */
  get(): Operation<T | undefined>;
}

/**
 * Unwrap the type of an `Operation`.
 * Analogous to the built in [`Awaited`](https://www.typescriptlang.org/docs/handbook/utility-types.html#awaitedtype) type.
 * Yielded<Operation<T>> === T
 */
export type Yielded<T extends Operation<unknown>> = T extends
  Operation<infer TYield> ? TYield
  : never;

/* low-level interface Which you probably will not need */

/**
 * @ignore
 */
export type Result<T> = {
  readonly ok: true;
  value: T;
} | {
  readonly ok: false;
  error: Error;
};

/**
 * @ignore
 */
export interface Instruction {
  (frame: Frame): Computation<Result<unknown>>;
}

import type { FrameResult } from "./run/types.ts";

/**
 * @ignore
 */
export interface Frame<T = unknown> extends Computation<FrameResult<T>> {
  id: number;
  context: Record<string, unknown>;
  exited?: true;
  aborted?: boolean;
  getTask(): Task<T>;
  createChild<C>(operation: () => Operation<C>): Frame<C>;
  enter(): void;
  crash(error: Error): Computation<Result<void>>;
  destroy(): Computation<Result<void>>;
}
